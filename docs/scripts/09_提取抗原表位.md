# 09_提取抗原表位 (Epitope Extraction)

# 1. 目标与输入输出

## 目标
从结构文件（CIF）中提取抗原表位及其局部微环境（Pocket），并将其结构化存储以便后续的聚类和对齐分析。

## 输入
*   **结构文件**: 下载并清洗后的 CIF 文件夹 (e.g., `data/raw_data/summary-decuplication-distance_threshold_9`).
*   **元数据**: 经过多次筛选去重的 CSV 文件 (e.g., `data/decuplication/summary-decuplication-distance_threshold_9.csv`).

## 输出
*   **汇总表格**: `data/extract_epitope/epitope_summary.csv`
    *   记录每个提取表位的元数据：`epitope_id`, `pdb_id`, `chain_ids`, `npz_path`, `num_residues` 等。
*   **结构数据 (NPZ)**: `data/extract_epitope/pockets/{epitope_id}.npz`
    *   存储裁剪后的原子级结构信息，保留用于重建拓扑的关键字段。

# 2. 技术方案

## 核心工具
*   **解析与计算**: 使用 `gemmi` (高效处理 CIF, Neighbor Search, Model 处理)。
*   **存储**: `numpy` (.npz) 压缩存储。

## 流程逻辑

### 1. 读取 (Reading)
*   按 CSV 行遍历（每一行代表一对 Antibody-Antigen 相互作用）。
*   使用 `gemmi` 读取 CIF 文件。
    *   **策略**: 默认读取第一个模型 (`Model 1`)。

### 2. 定义表位 (Identification)
*   **距离计算**: 计算抗体（重链 + 轻链）所有原子与抗原链原子的距离。
*   **阈值**: 距离 < **4.5 Å** 的抗原残基被标记为“原始表位”。
*   **多链处理**: 如果 CSV 指定抗原涉及多条链（如 `antigen_chain_id` 为 "A|B"），将它们视为一个整体进行距离计算和提取。

### 3. 过滤 (Filtering)
*   **残基数限制**: 默认保留残基数在 **[6, 60]** 之间的表位。
    *   此范围可通过脚本参数配置，避免硬编码。

### 4. 微环境提取 (AntiGenCropper)
*   **模块**: `src/antibody_antigen/cropper.py` 中的 `AntiGenCropper` 类。
*   **算法**: 改编自 Boltz-2 的 **Affinity Cropper (Algorithm 3)**。
*   **逻辑**:
    *   以识别出的“原始表位”残基为种子。
    *   在**序列维度**上向两侧扩展窗口（默认 `neighborhood_size=10`）。
    *   目的：捕获表位的结构上下文，形成连续的 Pocket，缓解仅提取接触残基导致的空间/序列不连续问题。

### 5. 存储格式 (NPZ)
每个 `.npz` 文件将包含以下数组（N 为裁剪后的原子总数）：
*   `coords`: (N, 3) float32 - 原子坐标
*   `atom_types`: (N,) str - 原子元素类型 (e.g., "C", "N", "O")
*   `residue_indices`: (N,) int - 残基在 Pocket 中的局部索引 (0..M-1)
*   `chain_ids`: (N,) str - **原始链 ID** (关键：用于区分多链抗原的各部分)
*   `res_seq_nums`: (N,) int - PDB 原始序列号
*   `res_names`: (N,) str - 残基名称 (e.g., "ALA", "TRP")

# 3. 进度追踪 (Implementation Progress)

- [x] **环境准备**: 确认 `gemmi`, `numpy`, `pandas`, `joblib` 依赖。
- [x] **核心模块 (`src/antibody_antigen/cropper.py`)**:
    - [x] 实现 `AntiGenCropper` 类结构。
    - [x] 实现序列窗口扩展逻辑 (Algorithm 3)。
    - [x] 实现从 Gemmi 结构提取原子数据并格式化为 Numpy 数组的功能。
- [x] **主流程脚本 (`scripts/09_extract_epitope.py`)**:
    - [x] 参数解析 (输入输出路径, 阈值配置: min/max residues, neighborhood)。
    - [x] 实现 `gemmi` CIF 读取与 Neighbor Search。
    - [x] 实现多链抗原的整合处理逻辑。
    - [x] 集成 `AntiGenCropper`。
    - [x] 实现并行处理 (Joblib)。
    - [x] 结果汇总与 CSV 输出。
- [x] **测试与验证**:
    - [x] 运行小规模测试集合。
    - [x] 验证 NPZ 文件内容（特别是多链抗原的 chain_ids 是否正确）。
    - [x] 检查日志，确认过滤逻辑生效。

# 4. 问题排查与解决 (Troubleshooting)

在开发与大规模测试过程中遇到的问题及解决方案：

1.  **Gemmi 链查找失败 (Chain Not Found)**
    *   **现象**: 脚本抛出 `ValueError: Chain X not found`，导致程序中断。
    *   **原因**: CSV 元数据中的 Chain ID 与 CIF 文件中的链命名不一致（可能是 `auth_asym_id` 与 `label_asym_id` 的差异，或数据本身的脏数据）。
    *   **解决**: 在 `extract_epitope_residues` 函数中，当查找链（`model[id]`）失败时，捕获 `LookupError` 和 `ValueError` 异常，记录日志并跳过该条目，防止整个流程崩溃。

2.  **空模型导致的返回值类型错误**
    *   **现象**: 抛出 `AttributeError: 'list' object has no attribute 'values'`。
    *   **原因**: 当一个 PDB 的所有抗体链都找不到时，函数 `extract_epitope_residues` 触发了早退（early return），但错误地返回了空列表 `[]`，而调用者预期返回字典 `Dict`。
    *   **解决**: 修正早退逻辑，当找不到抗体链时返回空字典 `{}`，与函数签名保持一致。

# 5. 后续规划：抗原对齐 (Alignment) & 聚类

*(待提取工作完成后实施)*

我们根据之前提取到的口袋根据结构来对齐。

1.  **相似度矩阵**: 把所有 epitope 拿出来，构造一个 pairwise 相似度矩阵。
2.  **粗筛**: 只在残基数差不超过某阈值 (e.g., 5) 的 pair 上比较。
3.  **结构比对**: 取它们的 Cα 坐标，用 Kabsch 算法求最佳刚体对齐，计算 RMSD。
4.  **序列比对**: 计算表位序列 identity。
5.  **图构建与聚类**:
    *   Edge 定义: RMSD ≤ 2.5–3.0 Å 且 Identity ∈ [40%, 95%]。
    *   连通分量分解 (Connected Components) 得到 Epitope Groups。