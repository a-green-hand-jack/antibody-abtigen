# 输入输出说明

## 输入

下载得到的 cif 文件的文件夹，比如 data/raw_data/summary-decuplication-distance_threshold_9
经过多次筛选去重的标记了可用抗原-抗体 id 的 csv 文件，比如 data/decuplication/summary-decuplication-distance_threshold_9.csv

## 输出

每一个抗原都应该得到一个记录，注意，我需要的是对完整的抗原而不是抗原的某一个抗原链。

# 抗原表位

## 抽取表位
从每个复合物里抽取“抗原表位”

对每一个保留下来的 cif 文件：

确定链：

从表格文件里面读取 file_name	pdb	H_chain_id	L_chain_id	H_chain_seq	L_chain_seq	H_chain_masked_seq	L_chain_masked_seq	antigen_chain_id	antigen_seq	antigen_type	resolution	scfv	date	index_in_summary

根据 file_name 得到 对应的 cif 文件的路径；根据 antigen_chain_id 确定抗原链。我们的处理要兼容单链和多链。


定义表位（Epitope）：

表位 = 抗原上所有与抗体原子距离 < 4.5–5.0 Å 的残基。

可以用 Cα–Cα 距离 < 8 Å，来定义表位。

实现上，用 Biopython / MDAnalysis 去遍历 “antigen residues × antibody residues” 距离即可。

过滤掉太极端的表位：

残基数 < 6：太小，不稳定，几乎没有信息；

残基数 > 60：非常大的表位，往往不是一个明确 epitope，可以先丢掉或单独处理。

给每个 epitope 写一条记录：

epitope_id: <PDBID>_<antigenChain>_<index>
pdb_path: path/to/pdb
antigen_chain: <chain id>
heavy_chain: <chain id(s)>
light_chain: <chain id(s)>
epitope_residues: [ (residue_number, insertion_code, residue_name), ... ]
epitope_coords: 对应残基 Cα 或侧链质心坐标


之后所有聚类都是在这些 epitope_* 条目上操作。

这个记录应该是在一个 csv 文件里面实现的

## 抗原提取

上一步得到的抗原表位在空间上可能是分离的几个氨基酸，在序列上也可能是不连续的，这样的得到的表位是不方便对齐的。
为了解决这个问题，可以参考 boltz2 在处理 protein-ligand pocket的的操作，也就是算法三。这里给出对应的伪代码：

---
**Algorithm 3: AFFINITY CROPPER**

**Input:** Token list `tokens`, minimum distance to the ligand `min_dist_protein_to_ligand`
**Input:** `max_tokens = 256`, `max_protein_tokens = 200`, `neighborhood_size = 10`

// Start with all ligand tokens
cropped_tokens ← tokens[mol_type = ligand]

// Min pooling over the residues’ atoms
min_dist_res_to_ligand ← MinPooling(min_dist_protein_to_ligand[protein])
res_idx_sorted ← argsort(min_dist_res_to_ligand)

// Add protein tokens around pocket residues
for res_idx in res_idx_sorted do
    Let res_tokens be the entries with res_idx
    Let chain_id be the asym_id of the current residue
    Let chain_tokens be protein tokens with asym_id = chain_id

    // Initialize residue window
    min_idx = max_idx = res_idx
    while len(res_tokens) < neighborhood_size do
        min_idx = min_idx - 1
        max_idx = max_idx + 1
        res_tokens ← all tokens in chain_tokens with res_idx ∈ [min_idx, max_idx]
    end

    Let new_tokens be the entries in res_tokens not in cropped_tokens

    // Check token limits
    if cropped_tokens ∪ new_tokens > max_tokens or (cropped_tokens ∪ new_tokens) ∩ protein_tokens > max_protein_tokens then
        break
    end

    cropped_tokens ← cropped_tokens ∪ new_tokens
end
**Output:** `cropped_tokens`
---

通过这个算法我们可以得到连续的抗原-抗体相互作用的位点的局部空间。
这个可以存储为 npz 文件或者别的什么文件以便快速的比较，并且应该有一个 csv 文件来记录我们裁切的情况，npz 文件和 cif 文件之间的映射等等信息。

## 抗原对齐

我们根据之前提取到的口袋根据结构来对齐。

把所有 epitope 拿出来，构造一个 pairwise 相似度矩阵。

对每对 epitope (i, j)：

只在 残基数差不超过某阈值 的 pair 上比较，比如 |len_i − len_j| ≤ 5；

取它们的 Cα 坐标，用 Kabsch 算法求最佳刚体对齐，计算 RMSD；

再计算表位序列 identity（基于简单的全局比对即可）。

如果一对 epitope 满足：

RMSD ≤ 2.5–3.0 Å

且表位序列 identity 在一个区间内（比如 40%–95%），
就认为它们“可算相似但不完全一样”，在图里连一条 edge。

最后，你在这个 cluster 内做 连通分量分解（connected components）：

每个连通分量就是一个“真正结构上彼此相似的 epitope group 候选”。
