这份设计文档针对 **A100 (80G) 显卡** 进行了优化，集成了 **ESM-2 (3B参数)** 进行表征，使用 **Gemmi** 处理结构，最后利用 **PyMOL API** 进行高精度结构对齐。

-----

# Epitope-Centric SAbDab Pipeline Design (A100 Optimized)

## 1\. 系统概述

本流程的目标是构建一个以“表位结构相似性”为核心的数据集，忽略序列同源性和物种差异。最终输出为一个 JSON 索引文件和一套对齐后的完整 CIF 结构文件。

### 核心策略

1.  **数据清洗**: 全程使用 `gemmi` 处理 mmCIF，标准化链 ID。
2.  **表征 (Embedding)**: 使用 **ESM-2 (3B)** 模型。
      * *策略决定*: **Full Context Embedding**。对完整的抗原链进行 Inference，提取表位对应残基的 Embedding，然后做 Mean Pooling。
      * *理由*: 抗体识别的是“蛋白质表面环境中的表位”。切断上下文（只输入表位片段）会丢失折叠环境信息；而 A100 显存足够支持全长推理，能获得更物理真实的表位特征。
3.  **匹配与分组**: 向量相似度 (Cosine) 初筛 + 图论分组。
4.  **最终对齐**: 使用 **PyMOL** (headless mode) 的 `super` 算法对齐同一组内的表位，并将变换矩阵应用到整个“抗原-抗体”复合物，保存完整的 CIF。

-----

## 2\. 目录结构

```text
project_root/
├── data/
│   ├── raw_cif/             # 原始 SAbDab 下载
│   ├── cleaned_cif/         # 清洗后的复合物 (Gemmi处理, 链重命名)
│   ├── aligned_cif/         # [最终产物] 分组并对齐后的复合物
│   ├── meta/
│   │   ├── antigen_meta.csv # 抗原元数据
│   │   ├── epitope_def.json # 表位定义 (PDBID -> Residue IDs)
│   │   └── final_index.json # [最终产物] 组索引
│   └── embeddings/          # HDF5 存储 ESM 特征
├── models/
│   └── esm_cache/           # Torch Hub 缓存
├── src/
│   ├── cleaner.py           # Gemmi 结构清洗
│   ├── extractor.py         # 表位定义
│   ├── encoder.py           # ESM-2 Inference (GPU)
│   ├── grouper.py           # 向量检索 + NetworkX
│   └── aligner.py           # PyMOL 结构对齐
├── config.yaml
└── main.py
```

-----

## 3\. 详细实现步骤

### 模块 I: 结构清洗与抗原定义 (`cleaner.py`)

**目标**: 统一文件格式，处理多聚体。
**工具**: `gemmi`

1.  **读取与清洗**:

      * 读取 `.cif`。
      * 移除水分子 (`water`) 和非相关配体。
      * **关键步骤**: 处理 Asymmetric Unit。如果 CIF 中包含多个抗原-抗体复合物拷贝，将其拆分或仅保留一份最完整的。
      * **重命名**: 强制将抗原链重命名为 `A`, `B`...，抗体重命名为 `H`, `L`。这对于后续 PyMOL 脚本编写至关重要。

2.  **抗原 ID 分配**:

      * 提取清洗后的抗原序列。
      * 使用 `CD-HIT` (identity \< 90%) 或 `MMseqs2` 聚类。
      * 生成 `antigen_meta.csv`: `[pdb_id, clean_antigen_chain_ids, unique_antigen_id, sequence]`。

### 模块 II: 表位提取 (`extractor.py`)

**目标**: 确定哪些残基是表位。
**逻辑**: 几何接触。

1.  **接触计算**:

      * 计算 抗原链原子 与 抗体链原子 (H+L) 之间的最小距离。
      * Cutoff: \< 4.5 Å (或 5.0 Å)。
      * **多链合并**: 如果抗体结合了抗原的 A 链和 B 链（如三聚体界面），将 A 和 B 上的接触残基合并为一个 `Epitope` 对象。

2.  **输出**: `epitope_def.json`

    ```json
    {
      "epi_1": {
        "pdb_id": "7k8t",
        "antigen_id": "cluster_102",
        "chains": {
          "A": [100, 101, 102, ...],
          "B": [45, 46, ...]
        },
        "antibody_chains": ["H", "L"]
      }
    }
    ```

### 模块 III: ESM-2 表征 (A100 核心部分) (`encoder.py`)

**目标**: 生成表位的向量指纹。
**模型**: `esm2_t36_3B_UR50D` (3 Billion params)。

**代码逻辑**:

```python
import torch
import esm
import h5py
import numpy as np

class EpitopeEncoder:
    def __init__(self, device="cuda"):
        # 下载并加载 3B 模型
        self.model, self.alphabet = esm.pretrained.esm2_t36_3B_UR50D()
        self.model.eval().to(device)
        self.batch_converter = self.alphabet.get_batch_converter()
        self.device = device

    def embed_epitope(self, full_sequence, epitope_residue_indices):
        """
        full_sequence: 抗原全长序列 (str)
        epitope_residue_indices: 表位在全长序列中的 0-based index list
        """
        data = [("protein1", full_sequence)]
        batch_labels, batch_strs, batch_tokens = self.batch_converter(data)
        batch_tokens = batch_tokens.to(self.device)

        with torch.no_grad():
            # 获取最后一层表征
            results = self.model(batch_tokens, repr_layers=[36], return_contacts=False)
            token_embeddings = results["representations"][36] # Shape: [1, seq_len+2, 2560]

        # 移除 CLS/EOS tokens
        seq_embeddings = token_embeddings[0, 1:-1, :]

        # 提取表位对应的向量
        # 注意：这里需要处理多链拼接的情况，如果 full_sequence 是多链拼接，indices 需对齐
        epitope_vectors = seq_embeddings[epitope_residue_indices]

        # Mean Pooling: 将残基集合压缩为一个向量
        final_embedding = torch.mean(epitope_vectors, dim=0).cpu().numpy()
        return final_embedding
```

### 模块 IV: 分组与图构建 (`grouper.py`)

1.  **向量检索**:
      * 使用 `faiss` 对所有表位向量建立索引。
      * 对每个表位，检索 Top-K (e.g., K=100) 近邻。
2.  **过滤**:
      * 排除相同 `antigen_id` 的结果。
      * 排除余弦相似度低于阈值 (e.g., 0.85) 的结果。
3.  **图构建**:
      * Nodes: Epitope IDs.
      * Edges: 满足相似度阈值的 Pair。
      * **Connected Components**: 找出连通分量，每个分量就是一个 Group。

### 模块 V: PyMOL 精细对齐与输出 (`aligner.py`)

**目标**: 物理对齐结构，输出最终文件。
**工具**: `pymol-open-source` (Python API)。

**逻辑**:
对于每个 Group:

1.  选定第一个成员作为 **Reference (Anchor)**。
2.  遍历其他成员 (Mobile)。
3.  **基于表位对齐**:
      * 在 PyMOL 中选中 Ref 的表位残基 (`sele ref_epi, ...`)。
      * 选中 Mobile 的表位残基 (`sele mob_epi, ...`)。
      * 使用 `cmd.super("mob_epi", "ref_epi", object="mobile_complex")`。
          * `super`: 结构对齐算法，不依赖序列，能够很好地处理非连续片段的几何匹配。
          * `object`: 关键参数，这会把计算出的变换矩阵应用到整个 Mobile 复合物上（包括抗体）。
4.  **保存**: 将变换后的 Mobile 复合物保存为 `.cif` 到 `aligned_cif/group_X/`。
5.  **记录**: 写入 JSON。

**代码片段**:

```python
import pymol
from pymol import cmd

def align_and_save(group_data, output_dir):
    pymol.finish_launching(['pymol', '-qc']) # Headless mode

    ref_id = group_data["members"][0]["id"]
    ref_path = group_data["members"][0]["path"]
    ref_resi = group_data["members"][0]["residues"] # e.g. "10-15+50-55"
    ref_chain = group_data["members"][0]["chain"]

    # Load Reference
    cmd.load(ref_path, "ref_obj")

    aligned_members = []

    # Selection string for PyMOL: chain A and resi 10+11+...
    # 注意 PyMOL 的 resi 写法是 10+11+12
    ref_sel = f"ref_obj and chain {ref_chain} and resi {ref_resi}"

    for member in group_data["members"][1:]:
        mob_path = member["path"]
        mob_resi = member["residues"]
        mob_chain = member["chain"]
        mob_name = f"mob_{member['id']}"

        cmd.load(mob_path, mob_name)
        mob_sel = f"{mob_name} and chain {mob_chain} and resi {mob_resi}"

        # 核心对齐: super (比 align 更适合低序列相似度)
        # 这里的 object=mob_name 确保整个复合物移动
        res = cmd.super(mob_sel, ref_sel, object=mob_name)
        rmsd = res[0]

        save_path = output_dir / f"{member['id']}_aligned.cif"
        cmd.save(str(save_path), mob_name)
        cmd.delete(mob_name)

        aligned_members.append({
            "id": member["id"],
            "filepath": str(save_path),
            "rmsd_to_ref": rmsd
        })

    cmd.delete("all")
    return aligned_members
```

-----

## 4\. 最终输出格式 (JSON)

文件: `final_dataset.json`

```json
[
  {
    "group_id": "group_001",
    "representative_epitope": "7k8t_A",
    "avg_similarity": 0.92,
    "members": [
      {
        "pdb_id": "7k8t",
        "antigen_id": "cluster_102",
        "type": "reference",
        "complex_cif": "data/aligned_cif/group_001/7k8t_cleaned.cif",
        "epitope_residues": [100, 101, 102, 200, 201],
        "antibody_chains": ["H", "L"]
      },
      {
        "pdb_id": "8xyz",
        "antigen_id": "cluster_55",
        "type": "aligned",
        "complex_cif": "data/aligned_cif/group_001/8xyz_aligned.cif",
        "epitope_residues": [12, 13, 14, 88, 89],
        "antibody_chains": ["H", "L"],
        "rmsd": 1.2
      }
    ]
  },
  ...
]
```

-----

## 5\. 环境配置与安装

在 A100 环境上，推荐使用 Conda + PyTorch + PyMOL。

```bash
# 1. 基础环境
conda create -n sabdab_env python=3.10 -y
conda activate sabdab_env

# 2. PyTorch (适配 A100 CUDA 11.8/12.x)
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118

# 3. 核心工具
pip install gemmi biotite esm h5py networkx pandas faiss-gpu typer

# 4. PyMOL Open Source (必须从 conda-forge 装)
conda install -c conda-forge pymol-open-source
```

## 6\. 执行清单 (Checklist)

1.  **Checkpoint 准备**: 首次运行代码会自动下载 ESM-2 模型，建议手动下载权重文件存入 `.cache`，防止网络中断。
2.  **PyMOL 路径**: 确保脚本能调用 `pymol` 命令，或者直接在 Python 中 `import pymol` 成功。
3.  **HDF5 压缩**: 存储 embedding 时使用 `compression="gzip"`，虽然慢一点但在海量数据下节省空间。
4.  **Residue Indexing**:
      * Gemmi/Biopython 读取的索引通常是 `label_seq_id` (连续的) 或 `auth_seq_id` (PDB原始编号)。
      * **严正警告**: ESM-2 使用的是序列的 0-based index。Gemmi 提取的序列必须和 ESM 输入的序列 100% 一致。
      * PyMOL 使用的是 `resi` (通常是 `auth_seq_id`)。
      * **解决方案**: 在 `cleaner.py` 阶段，建立一个映射表 `IndexMap: 0-based-index -> PDB-auth-residue-number`，传递给 PyMOL 模块使用。
